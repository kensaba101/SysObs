#include <systemc.h>
// Include common routines
#include <verilated.h>

// Generated by verilating fiapp.sv
#include "Vfiapp.h"

#define SIMULATE_UNTIL_TIME 40

int sc_main(int argc, char** argv) {
        // Prevent unused variable warnings
        if (false && argc && argv) {}

        // Set debug level, 0 is off, 9 is highest presently used
        // May be overridden by commandArgs
        Verilated::debug(0);

        // Randomization reset policy
        // May be overridden by commandArgs
        Verilated::randReset(2);

        // Pass arguments so Verilated code can see them, e.g. $value$plusargs
        // This needs to be called before you create any model
        Verilated::commandArgs(argc, argv);

        // Define Clock
        sc_clock clk("clk", 10, SC_NS, 0.5, 3, SC_NS, true);

        // Define interconnects
        sc_signal<bool> reset;
        sc_signal<bool> a;
        sc_signal<bool> enable;

        sc_signal<bool> o1;
        sc_signal<bool> o2;
        sc_signal<bool> o3;

        Vfiapp* top;
        top = new Vfiapp("top");

        // Attach signals to the model
        top->clk(clk); 

        top->reset(reset);
        top->a(a);
        top->enable(enable);

        top->o1(o1);
        top->o2(o2);
        top->o3(o3);

        
        // Initialize SC model
        sc_start(1, SC_NS);
        
        // Set some inputs
        top->reset = 0; //reset is active high
        top->a = 0;
        top->enable = 1; //active high

        while (!Verilated::gotFinish()) { 

            // Apply inputs
            if (sc_time_stamp() > sc_time(1, SC_NS) && sc_time_stamp() < sc_time(10, SC_NS)) {
                reset = 1;  // Assert reset
                cout << o1 << o2 << o3 << endl;
            } else if (sc_time_stamp() >= sc_time(10, SC_NS) && sc_time_stamp() < sc_time(20, SC_NS)){
                reset = 0;  // Deassert reset
                a = !a; 
                cout << o1 << o2 << o3 << endl; 
            } else if (sc_time_stamp() >= sc_time(20, SC_NS) && sc_time_stamp() < sc_time(30, SC_NS)){
                reset = 0;  // Deassert reset
                a = !a; 
                enable = 0; // Deassert enable
                cout << o1 << o2 << o3 << endl; 
            } else if (sc_time_stamp() >= sc_time(30, SC_NS) && sc_time_stamp() < sc_time(40, SC_NS)){
                reset = 0;  // Deassert reset
                a = !a; 
                enable = 1;  // Reassert enable
                cout << o1 << o2 << o3 << endl; 
            }

            
            sc_start(1, SC_NS); 
            if(sc_time_stamp() > sc_time(SIMULATE_UNTIL_TIME, SC_NS) ){
                break;
            }
        }

        top->final();    
        //delete top;
        return 0;
}